{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "optimized-image",
  "type": "registry:ui",
  "title": "Optimized Image",
  "description": "A framework-agnostic image component with Next.js optimization detection, lazy loading, error handling, and accessibility features.",
  "dependencies": [],
  "registryDependencies": [
    "utils"
  ],
  "files": [
    {
      "path": "src/registry/default/ui/optimized-image.tsx",
      "content": "\"use client\";\n\nimport React, { useState, useCallback, useRef, useEffect } from \"react\";\nimport { cn } from \"@/lib/utils\";\n\n// Check if Next.js Image is available\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nlet NextImage: React.ComponentType<any> | null = null;\ntry {\n  // eslint-disable-next-line @typescript-eslint/no-require-imports\n  NextImage = require(\"next/image\").default;\n} catch {\n  // Next.js not available\n}\n\nexport interface OptimizedImageProps\n  extends Omit<\n    React.ImgHTMLAttributes<HTMLImageElement>,\n    \"onLoad\" | \"onError\"\n  > {\n  src: string;\n  alt: string;\n  width?: number;\n  height?: number;\n  priority?: boolean;\n  quality?: number;\n  placeholder?: \"blur\" | \"empty\";\n  blurDataURL?: string;\n  fallbackSrc?: string;\n  onLoad?: (event: React.SyntheticEvent<HTMLImageElement, Event>) => void;\n  onError?: (event: React.SyntheticEvent<HTMLImageElement, Event>) => void;\n  lazy?: boolean;\n  className?: string;\n}\n\nexport const OptimizedImage = React.forwardRef<\n  HTMLImageElement,\n  OptimizedImageProps\n>(\n  (\n    {\n      src,\n      alt,\n      width,\n      height,\n      priority = false,\n      quality = 75,\n      placeholder = \"empty\",\n      blurDataURL,\n      fallbackSrc,\n      onLoad,\n      onError,\n      lazy = true,\n      className,\n      ...props\n    },\n    ref,\n  ) => {\n    const [imageSrc, setImageSrc] = useState(src);\n    const [isLoading, setIsLoading] = useState(true);\n    const [hasError, setHasError] = useState(false);\n    const [isInView, setIsInView] = useState(!lazy || priority);\n    const imgRef = useRef<HTMLImageElement>(null);\n    const observerRef = useRef<IntersectionObserver | null>(null);\n\n    // Intersection Observer for lazy loading\n    useEffect(() => {\n      if (!lazy || priority || isInView) return;\n\n      const observer = new IntersectionObserver(\n        ([entry]) => {\n          if (entry.isIntersecting) {\n            setIsInView(true);\n            observer.disconnect();\n          }\n        },\n        { threshold: 0.1, rootMargin: \"50px\" },\n      );\n\n      if (imgRef.current) {\n        observer.observe(imgRef.current);\n      }\n\n      observerRef.current = observer;\n\n      return () => {\n        observer.disconnect();\n      };\n    }, [lazy, priority, isInView]);\n\n    const handleLoad = useCallback(\n      (event: React.SyntheticEvent<HTMLImageElement, Event>) => {\n        setIsLoading(false);\n        setHasError(false);\n        onLoad?.(event);\n      },\n      [onLoad],\n    );\n\n    const handleError = useCallback(\n      (event: React.SyntheticEvent<HTMLImageElement, Event>) => {\n        setIsLoading(false);\n        setHasError(true);\n\n        if (fallbackSrc && imageSrc !== fallbackSrc) {\n          setImageSrc(fallbackSrc);\n          setHasError(false);\n          setIsLoading(true);\n        }\n\n        onError?.(event);\n      },\n      [onError, fallbackSrc, imageSrc],\n    );\n\n    // Use Next.js Image if available and in Next.js environment\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    if (\n      NextImage &&\n      typeof window !== \"undefined\" &&\n      (window as any).__NEXT_DATA__\n    ) {\n      return (\n        <NextImage\n          ref={ref}\n          src={imageSrc}\n          alt={alt}\n          width={width}\n          height={height}\n          priority={priority}\n          quality={quality}\n          placeholder={placeholder}\n          blurDataURL={blurDataURL}\n          onLoad={handleLoad}\n          onError={handleError}\n          className={cn(\n            \"transition-opacity duration-300\",\n            isLoading && \"opacity-0\",\n            !isLoading && \"opacity-100\",\n            hasError && \"opacity-50\",\n            className,\n          )}\n          {...props}\n        />\n      );\n    }\n\n    // Fallback to optimized HTML img\n    return (\n      <div\n        className={cn(\"relative overflow-hidden\", className)}\n        style={{ width, height }}\n      >\n        {/* Placeholder/Loading state */}\n        {isLoading && (\n          <div\n            className=\"absolute inset-0 bg-muted animate-pulse flex items-center justify-center\"\n            style={{ width, height }}\n          >\n            <div className=\"w-8 h-8 border-2 border-muted-foreground/20 border-t-muted-foreground/60 rounded-full animate-spin\" />\n          </div>\n        )}\n\n        {/* Blur placeholder */}\n        {placeholder === \"blur\" && blurDataURL && isLoading && (\n          // eslint-disable-next-line @next/next/no-img-element\n          <img\n            src={blurDataURL}\n            alt=\"\"\n            className=\"absolute inset-0 w-full h-full object-cover filter blur-sm scale-110\"\n            aria-hidden=\"true\"\n          />\n        )}\n\n        {/* Main image */}\n        {isInView && (\n          // eslint-disable-next-line @next/next/no-img-element\n          <img\n            ref={(node) => {\n              imgRef.current = node;\n              if (typeof ref === \"function\") {\n                ref(node);\n              } else if (ref) {\n                ref.current = node;\n              }\n            }}\n            src={imageSrc}\n            alt={alt}\n            width={width}\n            height={height}\n            loading={lazy && !priority ? \"lazy\" : \"eager\"}\n            decoding=\"async\"\n            onLoad={handleLoad}\n            onError={handleError}\n            className={cn(\n              \"transition-opacity duration-300 w-full h-full object-cover\",\n              isLoading && \"opacity-0\",\n              !isLoading && !hasError && \"opacity-100\",\n              hasError && \"opacity-50\",\n            )}\n            {...props}\n          />\n        )}\n\n        {/* Error state */}\n        {hasError && !fallbackSrc && (\n          <div className=\"absolute inset-0 bg-muted flex items-center justify-center\">\n            <div className=\"text-muted-foreground text-sm text-center p-4\">\n              <svg\n                className=\"w-8 h-8 mx-auto mb-2 opacity-50\"\n                fill=\"none\"\n                stroke=\"currentColor\"\n                viewBox=\"0 0 24 24\"\n              >\n                <path\n                  strokeLinecap=\"round\"\n                  strokeLinejoin=\"round\"\n                  strokeWidth={2}\n                  d=\"M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z\"\n                />\n              </svg>\n              Failed to load image\n            </div>\n          </div>\n        )}\n      </div>\n    );\n  },\n);\n\nOptimizedImage.displayName = \"OptimizedImage\";\n\n// Utility function to preload images\nexport const preloadImage = (src: string): Promise<void> => {\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    img.onload = () => resolve();\n    img.onerror = reject;\n    img.src = src;\n  });\n};\n\n// Hook for image preloading\nexport const useImagePreload = (sources: string[]) => {\n  const [loadedImages, setLoadedImages] = useState<Set<string>>(new Set());\n  const [failedImages, setFailedImages] = useState<Set<string>>(new Set());\n\n  useEffect(() => {\n    const preloadPromises = sources.map(async (src) => {\n      try {\n        await preloadImage(src);\n        setLoadedImages((prev) => new Set([...prev, src]));\n      } catch {\n        setFailedImages((prev) => new Set([...prev, src]));\n      }\n    });\n\n    Promise.allSettled(preloadPromises);\n  }, [sources]);\n\n  return { loadedImages, failedImages };\n};\n",
      "type": "registry:ui",
      "target": "components/soldevkit-ui/optimized-image.tsx"
    }
  ]
}