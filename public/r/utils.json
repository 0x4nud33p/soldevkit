{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "utils",
  "type": "registry:lib",
  "title": "Utils",
  "description": "Utility functions for class name merging with clsx and tailwind-merge.",
  "dependencies": [
    "clsx",
    "tailwind-merge",
    "@solana/web3.js"
  ],
  "files": [
    {
      "path": "src/registry/lib/utils.ts",
      "content": "import { clsx, type ClassValue } from \"clsx\";\nimport { twMerge } from \"tailwind-merge\";\nimport { PublicKey } from \"@solana/web3.js\";\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs));\n}\n\nexport const validatePublicKey = (address: PublicKey | string) => {\n  try {\n    if (typeof address == \"string\") {\n      new PublicKey(address);\n    } else {\n      address.toBase58();\n    }\n    return true;\n  } catch {\n    return false;\n  }\n};\n\nexport const shortAddress = (address: PublicKey | string) => {\n  const key = typeof address === \"string\" ? address : address.toBase58();\n  return `${key.slice(0, 4)}...${key.slice(-4)}`;\n};\n\n// API Cache Management\ninterface CacheEntry<T> {\n  data: T;\n  timestamp: number;\n  expiry: number;\n}\n\nclass APICache {\n  private cache = new Map<string, CacheEntry<unknown>>();\n  private readonly DEFAULT_TTL = 5 * 60 * 1000; // 5 minutes\n\n  set<T>(key: string, data: T, ttl: number = this.DEFAULT_TTL): void {\n    this.cache.set(key, {\n      data,\n      timestamp: Date.now(),\n      expiry: Date.now() + ttl,\n    });\n  }\n\n  get<T>(key: string): T | null {\n    const entry = this.cache.get(key);\n    if (!entry) return null;\n\n    if (Date.now() > entry.expiry) {\n      this.cache.delete(key);\n      return null;\n    }\n\n    return entry.data as T;\n  }\n\n  clear(): void {\n    this.cache.clear();\n  }\n\n  delete(key: string): void {\n    this.cache.delete(key);\n  }\n}\n\nexport const apiCache = new APICache();\n\n// Alchemy API Response Types\ninterface AlchemyAssetContent {\n  metadata?: {\n    name?: string;\n    description?: string;\n    symbol?: string;\n    attributes?: Array<{\n      trait_type: string;\n      value: string | number;\n    }>;\n  };\n  files?: Array<{\n    uri?: string;\n  }>;\n  links?: {\n    image?: string;\n    external_url?: string;\n  };\n}\n\ninterface AlchemyGrouping {\n  group_key: string;\n  group_value: string;\n}\n\ninterface AlchemyAsset {\n  content?: AlchemyAssetContent;\n  grouping?: AlchemyGrouping[];\n}\n\ninterface AlchemyResponse {\n  jsonrpc: string;\n  id: number;\n  result?: AlchemyAsset;\n  error?: {\n    message: string;\n  };\n}\n\n// NFT Metadata Types\nexport interface NFTMetadata {\n  name?: string;\n  description?: string;\n  image?: string;\n  external_url?: string;\n  attributes?: Array<{\n    trait_type: string;\n    value: string | number;\n  }>;\n  collection?: {\n    name?: string;\n    family?: string;\n  };\n}\n\n// Jupiter API Response Types\ntype JupiterTokenResponse = TokenInfo[];\n\n// Token Types\nexport interface TokenInfo {\n  address: string;\n  name: string;\n  symbol: string;\n  logoURI?: string;\n  decimals: number;\n}\n\n// Shared Alchemy API Utility\nexport const fetchNFTMetadata = async (\n  mintAddress: string,\n): Promise<NFTMetadata | null> => {\n  const cacheKey = `nft-${mintAddress}`;\n  const cached = apiCache.get<NFTMetadata>(cacheKey);\n  if (cached) return cached;\n\n  try {\n    const rpcUrl = process.env.NEXT_PUBLIC_ALCHEMY_RPC_URL;\n    if (!rpcUrl) {\n      throw new Error(\"Alchemy RPC URL not configured\");\n    }\n\n    const response = await fetch(rpcUrl, {\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      body: JSON.stringify({\n        jsonrpc: \"2.0\",\n        id: 1,\n        method: \"getAsset\",\n        params: { id: mintAddress },\n      }),\n    });\n\n    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);\n\n    const data: AlchemyResponse = await response.json();\n    if (data.error) throw new Error(data.error.message);\n\n    const asset = data.result;\n    if (!asset) return null;\n\n    const metadata: NFTMetadata = {\n      name: asset.content?.metadata?.name || \"Unknown NFT\",\n      description: asset.content?.metadata?.description,\n      image: asset.content?.files?.[0]?.uri || asset.content?.links?.image,\n      external_url: asset.content?.links?.external_url,\n      attributes: asset.content?.metadata?.attributes?.map((attr) => ({\n        trait_type: attr.trait_type,\n        value: attr.value,\n      })),\n      collection: {\n        name: asset.grouping?.find((g) => g.group_key === \"collection\")\n          ?.group_value,\n        family: asset.content?.metadata?.symbol,\n      },\n    };\n\n    // Cache for 10 minutes\n    apiCache.set(cacheKey, metadata, 10 * 60 * 1000);\n    return metadata;\n  } catch (error) {\n    console.error(\"Error fetching NFT metadata:\", error);\n    return null;\n  }\n};\n\n// Shared Jupiter Token API Utility\nexport const fetchJupiterTokens = async (): Promise<TokenInfo[]> => {\n  const cacheKey = \"jupiter-tokens\";\n  const cached = apiCache.get<TokenInfo[]>(cacheKey);\n  if (cached) return cached;\n\n  try {\n    const response = await fetch(\"https://tokens.jup.ag/tokens?tags=verified\");\n\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n\n    const tokens: JupiterTokenResponse = await response.json();\n\n    // Cache for 30 minutes\n    apiCache.set(cacheKey, tokens, 30 * 60 * 1000);\n    return tokens;\n  } catch (error) {\n    console.error(\"Error fetching Jupiter tokens:\", error);\n    return [];\n  }\n};\n\n// Find token by address or symbol\nexport const findToken = async (\n  addressOrSymbol: string,\n): Promise<TokenInfo | null> => {\n  const tokens = await fetchJupiterTokens();\n  return (\n    tokens.find(\n      (t) =>\n        t.address.toLowerCase() === addressOrSymbol.toLowerCase() ||\n        t.symbol.toLowerCase() === addressOrSymbol.toLowerCase(),\n    ) || null\n  );\n};\n",
      "type": "registry:lib",
      "target": "lib/utils.ts"
    }
  ]
}